<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulación de Trayectoria Parabólica en 2D</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
        }
        .chart {
            display: inline-block;
            margin: 20px;
            border: 1px solid #ddd;
        }
        #controls {
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <h2>Simulación de Trayectoria Parabólica en 2D</h2>
    <div id="controls">
        <label for="xTarget">Ingrese la distancia objetivo (x) en metros:</label>
        <input type="number" id="xTarget" value="30">
        <button onclick="startSimulation()">Iniciar Simulación</button>
        <p id="result"></p>
    </div>
    <div id="chart" class="chart"></div>

    <script>
        // Parámetros globales
        const g = 9.81; // Gravedad (m/s²)
        const v0 = 25; // Velocidad inicial (m/s)
        let escalaVectores = 0.1; // Escala para los vectores

        // Crear el SVG para D3.js
        const width = 800, height = 400;
        const svg = d3.select("#chart")
            .append("svg")
            .attr("width", width)
            .attr("height", height)
            .style("background-color", "#f3f3f3");

        // Función para iniciar la simulación
        function startSimulation() {
            const xTarget = parseFloat(document.getElementById('xTarget').value);
            const angleOptimo = findOptimalAngle(xTarget);
            document.getElementById('result').innerText = `Ángulo calculado para alcanzar x = ${xTarget} m: ${angleOptimo.toFixed(2)}°`;

            svg.selectAll("*").remove(); // Limpiar el SVG antes de dibujar
            drawTrajectory(xTarget, angleOptimo);
        }

        // Función para calcular el ángulo óptimo usando optimización
        function findOptimalAngle(xTarget) {
            const tolerance = 0.01; // Tolerancia para la optimización
            let angleLow = 0, angleHigh = 90;
            let angleOptimo = 45;

            while (angleHigh - angleLow > tolerance) {
                const angleMid = (angleLow + angleHigh) / 2;
                const yAtX = alturaEnX(angleMid, xTarget);

                if (yAtX > 0) {
                    angleLow = angleMid;
                } else {
                    angleHigh = angleMid;
                }

                angleOptimo = (angleLow + angleHigh) / 2;
            }
            return angleOptimo;
        }

        // Función para calcular la altura en x con un ángulo dado
        function alturaEnX(angle, xTarget) {
            const angleRad = angle * Math.PI / 180;
            return xTarget * Math.tan(angleRad) - (g * xTarget * xTarget) / (2 * v0 * v0 * Math.cos(angleRad) ** 2);
        }

        // Dibujar la trayectoria parabólica
        function drawTrajectory(xTarget, angle) {
            const angleRad = angle * Math.PI / 180;
            const points = [];
            const vx = v0 * Math.cos(angleRad);
            const vy0 = v0 * Math.sin(angleRad);

            // Generar puntos de la trayectoria
            for (let x = 0; x <= xTarget; x += 0.5) {
                const y = x * Math.tan(angleRad) - (g * x * x) / (2 * v0 * v0 * Math.cos(angleRad) ** 2);
                points.push([x, y]);
            }

            // Escalas para convertir metros a píxeles
            const xScale = d3.scaleLinear().domain([0, xTarget * 1.5]).range([50, width - 50]);
            const yScale = d3.scaleLinear().domain([0, Math.max(...points.map(p => p[1])) * 1.2]).range([height - 50, 50]);

            // Línea de trayectoria
            const line = d3.line()
                .x(d => xScale(d[0]))
                .y(d => yScale(d[1]));

            svg.append("path")
                .datum(points)
                .attr("d", line)
                .attr("fill", "none")
                .attr("stroke", "blue")
                .attr("stroke-width", 2);

            // Animación de la trayectoria
            let index = 0;
            function animatePoint() {
                if (index >= points.length) return;

                const [x, y] = points[index];
                const t = x / vx;
                const vy = vy0 - g * t;

                svg.selectAll(".point, .vector").remove();

                // Punto de posición actual
                svg.append("circle")
                    .attr("class", "point")
                    .attr("cx", xScale(x))
                    .attr("cy", yScale(y))
                    .attr("r", 5)
                    .attr("fill", "red");

                // Vector de velocidad en x (rojo)
                svg.append("line")
                    .attr("class", "vector")
                    .attr("x1", xScale(x))
                    .attr("y1", yScale(y))
                    .attr("x2", xScale(x + vx * escalaVectores))
                    .attr("y2", yScale(y))
                    .attr("stroke", "red")
                    .attr("stroke-width", 2);

                // Vector de velocidad en y (verde)
                svg.append("line")
                    .attr("class", "vector")
                    .attr("x1", xScale(x))
                    .attr("y1", yScale(y))
                    .attr("x2", xScale(x))
                    .attr("y2", yScale(y + vy * escalaVectores))
                    .attr("stroke", "green")
                    .attr("stroke-width", 2);

                // Vector de velocidad total (negro)
                svg.append("line")
                    .attr("class", "vector")
                    .attr("x1", xScale(x))
                    .attr("y1", yScale(y))
                    .attr("x2", xScale(x + vx * escalaVectores))
                    .attr("y2", yScale(y + vy * escalaVectores))
                    .attr("stroke", "black")
                    .attr("stroke-width", 2);

                index++;
                requestAnimationFrame(animatePoint);
            }

            animatePoint();

            // Ejes de la gráfica
            svg.append("line")
                .attr("x1", xScale(0))
                .attr("y1", yScale(0))
                .attr("x2", xScale(xTarget * 1.5))
                .attr("y2", yScale(0))
                .attr("stroke", "black")
                .attr("stroke-width", 1);

            svg.append("line")
                .attr("x1", xScale(0))
                .attr("y1", yScale(0))
                .attr("x2", xScale(0))
                .attr("y2", yScale(Math.max(...points.map(p => p[1])) * 1.2))
                .attr("stroke", "black")
                .attr("stroke-width", 1);
        }
    </script>
</body>
</html>
